# 2æ®µéšå‹•ç”»ä¼ç”»ç”Ÿæˆãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨­è¨ˆæ›¸

**ä½œæˆæ—¥æ™‚**: 2025å¹´1æœˆ12æ—¥ 14:39
**å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `src/usecases/transcript_to_draft_usecase.py`

## æ¦‚è¦

ç¾åœ¨ã®`TranscriptToDraftUsecase`ã¯ä»®ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã‚Œã‚’2æ®µéšæ§‹æˆã«ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹ã€‚

### ç¾åœ¨ã®å•é¡Œç‚¹
- å˜ä¸€ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ä¼ç”»æ›¸ã‚’ç”Ÿæˆã—ã¦ã„ã‚‹
- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒå›ºå®šåŒ–ã•ã‚Œã¦ãŠã‚Šã€ãƒ•ãƒƒã‚¯æŠ½å‡ºã¨è©³ç´°å°æœ¬ä½œæˆãŒåˆ†é›¢ã•ã‚Œã¦ã„ãªã„
- ä¸¦åˆ—å‡¦ç†ã«å¯¾å¿œã—ã¦ã„ãªã„

### æ–°ã—ã„æ§‹æˆ
1. **ãƒ•ãƒƒã‚¯æŠ½å‡ºãƒ•ã‚§ãƒ¼ã‚º**: æ–‡å­—èµ·ã“ã—ã‹ã‚‰10å€‹ã®ãƒ•ãƒƒã‚¯ã‚’æŠ½å‡º
2. **è©³ç´°å°æœ¬ä½œæˆãƒ•ã‚§ãƒ¼ã‚º**: å„ãƒ•ãƒƒã‚¯ã«å¯¾ã—ã¦è©³ç´°å°æœ¬ã‚’ä¸¦åˆ—ç”Ÿæˆ

## è¦æ±‚ä»•æ§˜

### â‘ ãƒ•ãƒƒã‚¯æŠ½å‡ºï¼ˆ10å€‹ï¼‰
- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: `project/hooks_prompt.txt`ã®å†…å®¹ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
- å‡ºåŠ›: 10å€‹ã®ãƒ•ãƒƒã‚¯æƒ…å ±ï¼ˆJSONå½¢å¼ï¼‰
- å„ãƒ•ãƒƒã‚¯ã«ã¯ä»¥ä¸‹ã®æƒ…å ±ã‚’å«ã‚€ï¼š
  - `first_hook`: æœ€åˆã®ãƒ•ãƒƒã‚¯
  - `second_hook`: 2ç•ªç›®ã®ãƒ•ãƒƒã‚¯
  - `third_hook`: 3ç•ªç›®ã®ãƒ•ãƒƒã‚¯
  - `last_conclusion`: æœ€å¾Œã®çµè«–
  - `summary`: è¦ç´„

### â‘¡è©³ç´°å°æœ¬ä½œæˆï¼ˆä¸¦åˆ—å®Ÿè¡Œï¼‰
- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: `project/draft_prompt.txt`ã®å†…å®¹ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
- å…¥åŠ›: ãƒ•ãƒƒã‚¯æƒ…å ± + æ–‡å­—èµ·ã“ã—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
- å‡ºåŠ›: 60ç§’ä»¥å†…ã®è©³ç´°å°æœ¬
- 10å€‹ã®ãƒ•ãƒƒã‚¯ã«å¯¾ã—ã¦ä¸¦åˆ—å®Ÿè¡Œ

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### å‡¦ç†ãƒ•ãƒ­ãƒ¼

```mermaid
graph TD
    A[TranscriptToDraftUsecase.execute] --> B[â‘ ãƒ•ãƒƒã‚¯æŠ½å‡º]
    B --> C[ChatGPTClient.extract_hooks]
    C --> D[10å€‹ã®ãƒ•ãƒƒã‚¯å–å¾—]
    D --> E[â‘¡è©³ç´°å°æœ¬ä½œæˆé–‹å§‹]
    E --> F[ä¸¦åˆ—å‡¦ç†: 10å€‹ã®ChatGPT APIå‘¼ã³å‡ºã—]
    F --> G[ChatGPTClient.generate_detailed_script]
    G --> H[10å€‹ã®è©³ç´°å°æœ¬å–å¾—]
    H --> I[çµæœçµ±åˆãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›]
```

### ã‚¯ãƒ©ã‚¹é–¢ä¿‚å›³

```mermaid
classDiagram
    class TranscriptToDraftUsecase {
        -chatgpt_client: ChatGPTClient
        -prompt_builder: PromptBuilder
        -srt_generator: SrtGenerator
        +execute(transcript_file_path, output_dir): TranscriptToDraftResult
        -extract_hooks(transcription): List[HookItem]
        -generate_detailed_scripts(hooks, transcription): List[DetailedScript]
    }

    class PromptBuilder {
        +build_hooks_prompt(transcription): str
        +build_script_prompt(hook, segments): str
    }

    class ChatGPTClient {
        +extract_hooks(prompt): List[HookItem]
        +generate_detailed_script(prompt): DetailedScript
    }

    class HookItem {
        +first_hook: str
        +second_hook: str
        +third_hook: str
        +last_conclusion: str
        +summary: str
    }

    class DetailedScript {
        +hook_item: HookItem
        +script_content: str
        +duration_seconds: int
    }

    TranscriptToDraftUsecase --> PromptBuilder
    TranscriptToDraftUsecase --> ChatGPTClient
    ChatGPTClient --> HookItem
    ChatGPTClient --> DetailedScript
```

## ãƒ‡ãƒ¼ã‚¿æ§‹é€ è¨­è¨ˆ

### æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚¯ãƒ©ã‚¹

#### HookItem
```python
@dataclass
class HookItem:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºçµæœã®å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ """
    first_hook: str
    second_hook: str
    third_hook: str
    last_conclusion: str
    summary: str
```

#### HooksExtractionResult
```python
@dataclass
class HooksExtractionResult:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºã®å…¨ä½“çµæœ"""
    items: List[HookItem]
    original_transcription: TranscriptionResult
```

#### DetailedScript
```python
@dataclass
class DetailedScript:
    """è©³ç´°å°æœ¬ç”Ÿæˆçµæœ"""
    hook_item: HookItem
    script_content: str
    duration_seconds: int
    segments_used: List[TranscriptionSegment]
```

#### TwoPhaseResult
```python
@dataclass
class TwoPhaseResult:
    """2æ®µéšå‡¦ç†ã®æœ€çµ‚çµæœ"""
    hooks_result: HooksExtractionResult
    detailed_scripts: List[DetailedScript]
    success: bool
    error_message: Optional[str] = None
```

## PromptBuilderæ‹¡å¼µè¨­è¨ˆ

### æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰

#### build_hooks_prompt
```python
def build_hooks_prompt(self, transcription: TranscriptionResult) -> str:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰

    project/hooks_prompt.txtã®å†…å®¹ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€
    æ–‡å­—èµ·ã“ã—çµæœã‚’çµ„ã¿è¾¼ã‚“ã ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
    """
```

#### build_script_prompt
```python
def build_script_prompt(self, hook_item: HookItem, segments: List[TranscriptionSegment]) -> str:
    """è©³ç´°å°æœ¬ä½œæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰

    project/draft_prompt.txtã®å†…å®¹ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€
    ãƒ•ãƒƒã‚¯æƒ…å ±ã¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’çµ„ã¿è¾¼ã‚“ã ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
    """
```

### ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†

```python
class PromptBuilder:
    def __init__(self):
        self.hooks_template = self._load_hooks_template()
        self.script_template = self._load_script_template()

    def _load_hooks_template(self) -> str:
        """project/hooks_prompt.txtã‹ã‚‰èª­ã¿è¾¼ã¿"""

    def _load_script_template(self) -> str:
        """project/draft_prompt.txtã‹ã‚‰èª­ã¿è¾¼ã¿"""
```

## ChatGPTClientæ‹¡å¼µè¨­è¨ˆ

### æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰

#### extract_hooks
```python
def extract_hooks(self, prompt: str) -> List[HookItem]:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºAPIå‘¼ã³å‡ºã—

    Returns:
        10å€‹ã®HookItemã®ãƒªã‚¹ãƒˆ
    """
```

#### generate_detailed_script
```python
def generate_detailed_script(self, prompt: str) -> DetailedScript:
    """è©³ç´°å°æœ¬ç”ŸæˆAPIå‘¼ã³å‡ºã—

    Returns:
        å˜ä¸€ã®è©³ç´°å°æœ¬
    """
```

### ä¸¦åˆ—å‡¦ç†å¯¾å¿œ

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

def generate_detailed_scripts_parallel(
    self,
    hook_items: List[HookItem],
    segments: List[TranscriptionSegment]
) -> List[DetailedScript]:
    """10å€‹ã®ãƒ•ãƒƒã‚¯ã«å¯¾ã—ã¦ä¸¦åˆ—ã§è©³ç´°å°æœ¬ã‚’ç”Ÿæˆ"""

    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = []
        for hook_item in hook_items:
            prompt = self.prompt_builder.build_script_prompt(hook_item, segments)
            future = executor.submit(self.generate_detailed_script, prompt)
            futures.append(future)

        results = [future.result() for future in futures]

    return results
```

## TranscriptToDraftUsecase ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨­è¨ˆ

### æ–°ã—ã„å‡¦ç†ãƒ•ãƒ­ãƒ¼

```python
def execute(self, transcript_file_path: str, output_dir: str) -> TranscriptToDraftResult:
    """2æ®µéšå‡¦ç†ã®å®Ÿè¡Œ"""

    # 1. æ—¢å­˜ã®å‰å‡¦ç†ï¼ˆå…¥åŠ›æ¤œè¨¼ã€transcriptèª­ã¿è¾¼ã¿ï¼‰
    transcription = self._load_transcript(transcript_file_path)

    # 2. ãƒ•ã‚§ãƒ¼ã‚º1: ãƒ•ãƒƒã‚¯æŠ½å‡º
    hooks_result = self._extract_hooks_phase(transcription)

    # 3. ãƒ•ã‚§ãƒ¼ã‚º2: è©³ç´°å°æœ¬ä½œæˆï¼ˆä¸¦åˆ—ï¼‰
    detailed_scripts = self._generate_scripts_phase(hooks_result)

    # 4. çµæœçµ±åˆãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
    return self._generate_output_files(hooks_result, detailed_scripts, output_dir)
```

### æ–°ã—ã„ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰

```python
def _extract_hooks_phase(self, transcription: TranscriptionResult) -> HooksExtractionResult:
    """ãƒ•ã‚§ãƒ¼ã‚º1: ãƒ•ãƒƒã‚¯æŠ½å‡º"""

def _generate_scripts_phase(self, hooks_result: HooksExtractionResult) -> List[DetailedScript]:
    """ãƒ•ã‚§ãƒ¼ã‚º2: è©³ç´°å°æœ¬ä½œæˆï¼ˆä¸¦åˆ—ï¼‰"""

def _generate_output_files(
    self,
    hooks_result: HooksExtractionResult,
    detailed_scripts: List[DetailedScript],
    output_dir: str
) -> TranscriptToDraftResult:
    """çµæœçµ±åˆã¨ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›"""
```

## å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«è¨­è¨ˆ

### æ–°ã—ã„å‡ºåŠ›å½¢å¼

#### hooks_result.json
```json
{
  "extraction_timestamp": "2025-01-12T14:39:00+09:00",
  "original_video": "video_name",
  "items": [
    {
      "first_hook": "...",
      "second_hook": "...",
      "third_hook": "...",
      "last_conclusion": "...",
      "summary": "..."
    }
  ]
}
```

#### detailed_scripts.md
```markdown
# è©³ç´°å°æœ¬é›†

## ãƒ•ãƒƒã‚¯1: [summary]

### å°æœ¬æ§‹æˆ
[00:00â€“00:06] ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‹ãƒ†ãƒ­ãƒƒãƒ—
...

## ãƒ•ãƒƒã‚¯2: [summary]
...
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¨­è¨ˆ

### æ–°ã—ã„ä¾‹å¤–ã‚¯ãƒ©ã‚¹

```python
class HooksExtractionError(TranscriptToDraftUsecaseError):
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºã‚¨ãƒ©ãƒ¼"""

class ScriptGenerationError(TranscriptToDraftUsecaseError):
    """å°æœ¬ç”Ÿæˆã‚¨ãƒ©ãƒ¼"""

class ParallelProcessingError(TranscriptToDraftUsecaseError):
    """ä¸¦åˆ—å‡¦ç†ã‚¨ãƒ©ãƒ¼"""
```

### éƒ¨åˆ†å¤±æ•—å¯¾å¿œ

- ãƒ•ãƒƒã‚¯æŠ½å‡ºãŒå¤±æ•—ã—ãŸå ´åˆ: å‡¦ç†ã‚’ä¸­æ–­
- è©³ç´°å°æœ¬ç”Ÿæˆã§ä¸€éƒ¨å¤±æ•—ã—ãŸå ´åˆ: æˆåŠŸã—ãŸåˆ†ã ã‘å‡ºåŠ›
- å…¨ã¦å¤±æ•—ã—ãŸå ´åˆ: ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦å‡¦ç†

## å®Ÿè£…é †åº

1. **æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å®Ÿè£…** (`src/models/`)
2. **PromptBuilderã®æ‹¡å¼µ** (`src/builders/prompt_builder.py`)
3. **ChatGPTClientã®æ‹¡å¼µ** (`src/clients/chatgpt_client.py`)
4. **TranscriptToDraftUsecaseã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°** (`src/usecases/transcript_to_draft_usecase.py`)
5. **ãƒ†ã‚¹ãƒˆã®æ›´æ–°**
6. **çµ±åˆãƒ†ã‚¹ãƒˆ**

## äº’æ›æ€§ã¸ã®é…æ…®

- æ—¢å­˜ã®APIã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ç¶­æŒ
- å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã¯æ‹¡å¼µï¼ˆæ—¢å­˜å½¢å¼ã‚‚ä½µç”¨ï¼‰
- è¨­å®šã«ã‚ˆã‚Šå¾“æ¥ã®å˜ä¸€ãƒ•ã‚§ãƒ¼ã‚ºå‡¦ç†ã‚‚é¸æŠå¯èƒ½

---

## å…·ä½“çš„ãªå®Ÿè£…ã‚³ãƒ¼ãƒ‰è¨­è¨ˆ

### 1. æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚¯ãƒ©ã‚¹ (`src/models/hooks.py`)

```python
"""ãƒ•ãƒƒã‚¯é–¢é€£ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ """

from dataclasses import dataclass
from typing import List, Optional

from .transcription import TranscriptionResult, TranscriptionSegment


@dataclass
class HookItem:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºçµæœã®å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ 

    Attributes:
        first_hook: æœ€åˆã®ãƒ•ãƒƒã‚¯
        second_hook: 2ç•ªç›®ã®ãƒ•ãƒƒã‚¯
        third_hook: 3ç•ªç›®ã®ãƒ•ãƒƒã‚¯
        last_conclusion: æœ€å¾Œã®çµè«–
        summary: è¦ç´„
    """
    first_hook: str
    second_hook: str
    third_hook: str
    last_conclusion: str
    summary: str


@dataclass
class HooksExtractionResult:
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºã®å…¨ä½“çµæœ

    Attributes:
        items: ãƒ•ãƒƒã‚¯ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆï¼ˆ10å€‹ï¼‰
        original_transcription: å…ƒã®æ–‡å­—èµ·ã“ã—çµæœ
    """
    items: List[HookItem]
    original_transcription: TranscriptionResult


@dataclass
class DetailedScript:
    """è©³ç´°å°æœ¬ç”Ÿæˆçµæœ

    Attributes:
        hook_item: å¯¾å¿œã™ã‚‹ãƒ•ãƒƒã‚¯ã‚¢ã‚¤ãƒ†ãƒ 
        script_content: å°æœ¬å†…å®¹
        duration_seconds: æƒ³å®šå†ç”Ÿæ™‚é–“ï¼ˆç§’ï¼‰
        segments_used: ä½¿ç”¨ã•ã‚ŒãŸã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
    """
    hook_item: HookItem
    script_content: str
    duration_seconds: int
    segments_used: List[TranscriptionSegment]


@dataclass
class TwoPhaseResult:
    """2æ®µéšå‡¦ç†ã®æœ€çµ‚çµæœ

    Attributes:
        hooks_result: ãƒ•ãƒƒã‚¯æŠ½å‡ºçµæœ
        detailed_scripts: è©³ç´°å°æœ¬ã®ãƒªã‚¹ãƒˆ
        success: å‡¦ç†æˆåŠŸãƒ•ãƒ©ã‚°
        error_message: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¤±æ•—æ™‚ï¼‰
    """
    hooks_result: HooksExtractionResult
    detailed_scripts: List[DetailedScript]
    success: bool
    error_message: Optional[str] = None
```

### 2. PromptBuilderæ‹¡å¼µå®Ÿè£…

```python
"""ChatGPTç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ‹¡å¼µç‰ˆï¼‰"""

import os
from pathlib import Path
from typing import List

from ..models.transcription import TranscriptionResult, TranscriptionSegment
from ..models.hooks import HookItem


class PromptBuilder:
    """ChatGPTç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆã‚¯ãƒ©ã‚¹ï¼ˆ2æ®µéšå¯¾å¿œç‰ˆï¼‰"""

    def __init__(self):
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿"""
        self.hooks_template = self._load_hooks_template()
        self.script_template = self._load_script_template()

    def _load_hooks_template(self) -> str:
        """ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿"""
        template_path = Path("project/hooks_prompt.txt")
        if not template_path.exists():
            raise FileNotFoundError(f"ãƒ•ãƒƒã‚¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {template_path}")

        with open(template_path, "r", encoding="utf-8") as f:
            return f.read()

    def _load_script_template(self) -> str:
        """è©³ç´°å°æœ¬ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿"""
        template_path = Path("project/draft_prompt.txt")
        if not template_path.exists():
            raise FileNotFoundError(f"å°æœ¬ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {template_path}")

        with open(template_path, "r", encoding="utf-8") as f:
            return f.read()

    def build_hooks_prompt(self, transcription: TranscriptionResult) -> str:
        """ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰

        Args:
            transcription: æ–‡å­—èµ·ã“ã—çµæœ

        Returns:
            ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        self._validate_transcription(transcription)

        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        segments_text = self._format_segments(transcription.segments)

        # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«æ–‡å­—èµ·ã“ã—æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã¿
        prompt = self.hooks_template + f"""

# å‹•ç”»æ›¸ãèµ·ã“ã—

## å…¨ä½“ãƒ†ã‚­ã‚¹ãƒˆ
{transcription.full_text}

## ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
{segments_text}
"""

        return prompt

    def build_script_prompt(self, hook_item: HookItem, segments: List[TranscriptionSegment]) -> str:
        """è©³ç´°å°æœ¬ä½œæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰

        Args:
            hook_item: ãƒ•ãƒƒã‚¯æƒ…å ±
            segments: æ–‡å­—èµ·ã“ã—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ

        Returns:
            è©³ç´°å°æœ¬ä½œæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        # ãƒ•ãƒƒã‚¯æƒ…å ±ã‚’JSONå½¢å¼ã§æ•´å½¢
        item_json = f"""{{
    "first_hook": "{hook_item.first_hook}",
    "second_hook": "{hook_item.second_hook}",
    "third_hook": "{hook_item.third_hook}",
    "last_conclusion": "{hook_item.last_conclusion}",
    "summary": "{hook_item.summary}"
}}"""

        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’JSONå½¢å¼ã§æ•´å½¢
        segments_json = "[\n"
        for segment in segments:
            segments_json += f"""    {{
        "start_time": {segment.start_time},
        "end_time": {segment.end_time},
        "text": "{segment.text}"
    }},\n"""
        segments_json = segments_json.rstrip(",\n") + "\n]"

        # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã¿
        prompt = self.script_template.replace("- `item`: {", f"- `item`: {item_json}")
        prompt = prompt.replace("- `segments`: [", f"- `segments`: {segments_json}")

        return prompt
```

### 3. ChatGPTClientæ‹¡å¼µå®Ÿè£…

```python
"""ChatGPT APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ‹¡å¼µç‰ˆï¼‰"""

import json
import time
from typing import Any, List
from concurrent.futures import ThreadPoolExecutor, as_completed

from openai import OpenAI

from ..models.hooks import HookItem, DetailedScript


class ChatGPTClient:
    """ChatGPT APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆ2æ®µéšå‡¦ç†å¯¾å¿œç‰ˆï¼‰"""

    def extract_hooks(self, prompt: str) -> List[HookItem]:
        """ãƒ•ãƒƒã‚¯æŠ½å‡ºAPIå‘¼ã³å‡ºã—

        Args:
            prompt: ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ

        Returns:
            10å€‹ã®HookItemã®ãƒªã‚¹ãƒˆ
        """
        self._validate_prompt(prompt)

        raw_response = self._call_chatgpt_api(prompt)
        json_data = self._parse_json_response(raw_response)
        self._validate_hooks_response_structure(json_data)

        return self._convert_to_hook_items(json_data)

    def generate_detailed_script(self, prompt: str) -> DetailedScript:
        """è©³ç´°å°æœ¬ç”ŸæˆAPIå‘¼ã³å‡ºã—

        Args:
            prompt: è©³ç´°å°æœ¬ç”Ÿæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ

        Returns:
            å˜ä¸€ã®è©³ç´°å°æœ¬
        """
        self._validate_prompt(prompt)

        raw_response = self._call_chatgpt_api(prompt)

        # å°æœ¬ã¯æ§‹é€ åŒ–ã•ã‚ŒãŸJSONã§ã¯ãªããƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¿”ã•ã‚Œã‚‹
        return DetailedScript(
            hook_item=None,  # å¾Œã§è¨­å®š
            script_content=raw_response,
            duration_seconds=60,  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            segments_used=[]  # å¾Œã§è¨­å®š
        )

    def generate_detailed_scripts_parallel(
        self,
        hook_items: List[HookItem],
        segments: List[TranscriptionSegment],
        prompt_builder
    ) -> List[DetailedScript]:
        """10å€‹ã®ãƒ•ãƒƒã‚¯ã«å¯¾ã—ã¦ä¸¦åˆ—ã§è©³ç´°å°æœ¬ã‚’ç”Ÿæˆ

        Args:
            hook_items: ãƒ•ãƒƒã‚¯ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆ
            segments: æ–‡å­—èµ·ã“ã—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            prompt_builder: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ“ãƒ«ãƒ€ãƒ¼

        Returns:
            è©³ç´°å°æœ¬ã®ãƒªã‚¹ãƒˆ
        """
        detailed_scripts = []

        # ä¸¦åˆ—å‡¦ç†ï¼ˆæœ€å¤§5ä¸¦åˆ—ï¼‰
        with ThreadPoolExecutor(max_workers=5) as executor:
            # å„ãƒ•ãƒƒã‚¯ã«å¯¾ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’æŠ•å…¥
            future_to_hook = {}
            for hook_item in hook_items:
                prompt = prompt_builder.build_script_prompt(hook_item, segments)
                future = executor.submit(self.generate_detailed_script, prompt)
                future_to_hook[future] = hook_item

            # çµæœã‚’åé›†
            for future in as_completed(future_to_hook):
                hook_item = future_to_hook[future]
                try:
                    script = future.result()
                    # ãƒ•ãƒƒã‚¯æƒ…å ±ã‚’è¨­å®š
                    script.hook_item = hook_item
                    script.segments_used = segments  # å…¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è¨­å®š
                    detailed_scripts.append(script)
                except Exception as e:
                    # å€‹åˆ¥ã®å¤±æ•—ã¯è­¦å‘Šã¨ã—ã¦è¨˜éŒ²ã—ã€å‡¦ç†ã‚’ç¶™ç¶š
                    print(f"ãƒ•ãƒƒã‚¯ '{hook_item.summary}' ã®å°æœ¬ç”Ÿæˆã«å¤±æ•—: {e}")

        return detailed_scripts

    def _validate_hooks_response_structure(self, data: dict[str, Any]) -> None:
        """ãƒ•ãƒƒã‚¯æŠ½å‡ºãƒ¬ã‚¹ãƒãƒ³ã‚¹JSONã®æ§‹é€ æ¤œè¨¼"""
        if "items" not in data:
            raise ValidationError("ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«'items'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“")

        required_fields = [
            "first_hook",
            "second_hook",
            "third_hook",
            "last_conclusion",
            "summary"
        ]

        for i, item in enumerate(data["items"]):
            for field in required_fields:
                if field not in item:
                    raise ValidationError(
                        f"ã‚¢ã‚¤ãƒ†ãƒ {i}ã«å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰'{field}'ãŒã‚ã‚Šã¾ã›ã‚“",
                        field_name=field,
                    )

    def _convert_to_hook_items(self, data: dict[str, Any]) -> List[HookItem]:
        """JSONãƒ‡ãƒ¼ã‚¿ã‚’HookItemã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã«å¤‰æ›"""
        hook_items = []

        for item in data["items"]:
            hook_item = HookItem(
                first_hook=item["first_hook"],
                second_hook=item["second_hook"],
                third_hook=item["third_hook"],
                last_conclusion=item["last_conclusion"],
                summary=item["summary"]
            )
            hook_items.append(hook_item)

        return hook_items
```

### 4. TranscriptToDraftUsecase ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å®Ÿè£…

```python
"""æ–‡å­—èµ·ã“ã—â†’ä¼ç”»æ›¸ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ï¼ˆ2æ®µéšå‡¦ç†ç‰ˆï¼‰"""

import json
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo
from typing import List

from ..models.hooks import HooksExtractionResult, DetailedScript


class HooksExtractionError(Exception):
    """ãƒ•ãƒƒã‚¯æŠ½å‡ºã‚¨ãƒ©ãƒ¼"""
    pass


class ScriptGenerationError(Exception):
    """å°æœ¬ç”Ÿæˆã‚¨ãƒ©ãƒ¼"""
    pass


class TranscriptToDraftUsecase:
    """æ–‡å­—èµ·ã“ã—ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ä¼ç”»æ›¸ã¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ï¼ˆ2æ®µéšå‡¦ç†ç‰ˆï¼‰"""

    def execute(self, transcript_file_path: str, output_dir: str) -> TranscriptToDraftResult:
        """2æ®µéšå‡¦ç†ã«ã‚ˆã‚‹ä¼ç”»æ›¸ã¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ"""
        try:
            # 1. æ—¢å­˜ã®å‰å‡¦ç†
            self._validate_input(transcript_file_path, output_dir)
            self._prepare_output_directory(output_dir)
            transcription = self._load_transcript(transcript_file_path)

            # 2. ãƒ•ã‚§ãƒ¼ã‚º1: ãƒ•ãƒƒã‚¯æŠ½å‡º
            hooks_result = self._extract_hooks_phase(transcription)

            # 3. ãƒ•ã‚§ãƒ¼ã‚º2: è©³ç´°å°æœ¬ä½œæˆï¼ˆä¸¦åˆ—ï¼‰
            detailed_scripts = self._generate_scripts_phase(hooks_result)

            # 4. çµæœçµ±åˆãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
            return self._generate_output_files(
                hooks_result,
                detailed_scripts,
                transcript_file_path,
                output_dir
            )

        except Exception as e:
            return TranscriptToDraftResult(
                success=False,
                draft_file_path="",
                subtitle_file_path="",
                error_message=str(e)
            )

    def _extract_hooks_phase(self, transcription: TranscriptionResult) -> HooksExtractionResult:
        """ãƒ•ã‚§ãƒ¼ã‚º1: ãƒ•ãƒƒã‚¯æŠ½å‡º"""
        try:
            # ãƒ•ãƒƒã‚¯æŠ½å‡ºç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            hooks_prompt = self.prompt_builder.build_hooks_prompt(transcription)

            # ChatGPT APIã§ãƒ•ãƒƒã‚¯æŠ½å‡º
            hook_items = self.chatgpt_client.extract_hooks(hooks_prompt)

            return HooksExtractionResult(
                items=hook_items,
                original_transcription=transcription
            )

        except Exception as e:
            raise HooksExtractionError(f"ãƒ•ãƒƒã‚¯æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ: {e}") from e

    def _generate_scripts_phase(self, hooks_result: HooksExtractionResult) -> List[DetailedScript]:
        """ãƒ•ã‚§ãƒ¼ã‚º2: è©³ç´°å°æœ¬ä½œæˆï¼ˆä¸¦åˆ—ï¼‰"""
        try:
            # ä¸¦åˆ—ã§è©³ç´°å°æœ¬ã‚’ç”Ÿæˆ
            detailed_scripts = self.chatgpt_client.generate_detailed_scripts_parallel(
                hooks_result.items,
                hooks_result.original_transcription.segments,
                self.prompt_builder
            )

            if not detailed_scripts:
                raise ScriptGenerationError("å…¨ã¦ã®å°æœ¬ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ")

            return detailed_scripts

        except Exception as e:
            raise ScriptGenerationError(f"è©³ç´°å°æœ¬ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {e}") from e

    def _save_hooks_result(self, hooks_result: HooksExtractionResult, video_name: str, output_dir: str) -> str:
        """ãƒ•ãƒƒã‚¯æŠ½å‡ºçµæœã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        hooks_file_path = Path(output_dir) / f"{video_name}_hooks.json"

        hooks_data = {
            "extraction_timestamp": self._get_current_datetime(),
            "original_video": video_name,
            "items": [
                {
                    "first_hook": item.first_hook,
                    "second_hook": item.second_hook,
                    "third_hook": item.third_hook,
                    "last_conclusion": item.last_conclusion,
                    "summary": item.summary
                }
                for item in hooks_result.items
            ]
        }

        with open(hooks_file_path, "w", encoding="utf-8") as f:
            json.dump(hooks_data, f, ensure_ascii=False, indent=2)

        return str(hooks_file_path)

    def _save_detailed_scripts(self, detailed_scripts: List[DetailedScript], video_name: str, output_dir: str) -> str:
        """è©³ç´°å°æœ¬ã‚’Markdownãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        scripts_file_path = Path(output_dir) / f"{video_name}_detailed_scripts.md"

        content_lines = [
            "# è©³ç´°å°æœ¬é›†",
            "",
            f"**å…ƒå‹•ç”»**: {video_name}",
            f"**ç”Ÿæˆæ—¥æ™‚**: {self._get_current_datetime()}",
            f"**å°æœ¬æ•°**: {len(detailed_scripts)}",
            "",
            "---",
            ""
        ]

        for i, script in enumerate(detailed_scripts, 1):
            content_lines.extend([
                f"## ãƒ•ãƒƒã‚¯{i}: {script.hook_item.summary}",
                "",
                f"**æƒ³å®šæ™‚é–“**: {script.duration_seconds}ç§’",
                "",
                "### ãƒ•ãƒƒã‚¯è©³ç´°",
                f"- **First Hook**: {script.hook_item.first_hook}",
                f"- **Second Hook**: {script.hook_item.second_hook}",
                f"- **Third Hook**: {script.hook_item.third_hook}",
                f"- **Last Conclusion**: {script.hook_item.last_conclusion}",
                "",
                "### å°æœ¬å†…å®¹",
                script.script_content,
                "",
                "---",
                ""
            ])

        content = "\n".join(content_lines)

        with open(scripts_file_path, "w", encoding="utf-8") as f:
            f.write(content)

        return str(scripts_file_path)
```

### 5. ä½¿ç”¨ä¾‹

```python
# ä½¿ç”¨ä¾‹
def main():
    # ä¾å­˜æ€§æ³¨å…¥
    chatgpt_client = ChatGPTClient(api_key=os.getenv("OPENAI_API_KEY"))
    prompt_builder = PromptBuilder()
    srt_generator = SrtGenerator()

    # ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®Ÿè¡Œ
    usecase = TranscriptToDraftUsecase(chatgpt_client, prompt_builder, srt_generator)
    result = usecase.execute("intermediate/video_transcript.json", "output/")

    if result.success:
        print(f"âœ… å‡¦ç†å®Œäº†")
        print(f"ğŸ“„ è©³ç´°å°æœ¬: {result.draft_file_path}")
        print(f"ğŸ“ å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«: {result.subtitle_file_path}")
    else:
        print(f"âŒ å‡¦ç†å¤±æ•—: {result.error_message}")
```

---

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€ãƒ•ãƒƒã‚¯æŠ½å‡ºã¨è©³ç´°å°æœ¬ä½œæˆã®2æ®µéšå‡¦ç†ã‚’å®Ÿç¾ã—ã€ä¸¦åˆ—å‡¦ç†ã«ã‚ˆã‚‹ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã‚’å›³ã‚‹ã€‚
